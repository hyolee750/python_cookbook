### 1.11 命名切片

#### 问题

你的程序已经因为硬编码切片索引成为了不可读的混乱，你想要清理它

#### 解决方案

假如你有一些代码从一个固定字段的字符串记录提取具体的数据字段

```python
###### 0123456789012345678901234567890123456789012345678901234567890'
record = '....................100.......513.25..........'
cost = int(record[20:32]) * float(record[40:48])
```

为什么不像这样命名切片替换它？

```python
SHARES = slice(20,32)
PRICE = slice(40,48)
cost = int(record[SHARES]) * float(record[PRICE])
```

最后的版本，你避免了很多硬编码的索引，你正在做的事情变得更加清晰

#### 讨论

作为一个一般的规则，写很多硬编码索引的代码会导致可读性和维护的混乱。例如，如果你一年后回到该代码，你会看到它，会想当你在写这个代码的时候你在想什么。之前显示的解决方案是简单的一个更清楚的方式显示你的代码实际上是做什么的。

一般来说，内置的`slice()`创建了一个切片对象，可以用于slice被使用的任何地方，例如：

```python
>>> items = [0, 1, 2, 3, 4, 5, 6]
>>> a = slice(2, 4)
>>> items[2:4]
[2,3]
>>> items[a]
[2,3]
>>> items[a] = [10,11]
>>> items
[0,1,10,11,4,5,6]
>>> del items[a]
>>> items
[0,1,4,5,6]
```

如果你有一个`slice`实例，你可以通过看它的`s.start`，`s.stop`,`s.step`属性来获取更多的信息。例如：

```python
>>> a = slice(10,50,2)
>>> a.start
10
>>> a.stop
50
>>> a.step
2
>>>
```

除此之外，你可以使用它的`indices(size)`方法映射一个切片到一个具体大小的序列。这个方法会返回一个元组`(start,stop,step)`,所有的值都被微妙的限制来适用边界之内。例如：

```python
>>> s = 'HelloWorld'
>>> a.indices(len(s))
(5,10,2)
>>> for i in range(*a.indices(len(s)))
		print(s[i])
W
r
d
>>>
```

